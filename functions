fail() {
    echo -e "\e[1;31m[fail]\e[0m $@"
    kill -INT $$ # kills only the function stack and not the entire shell
}

requires() {
    for arg in $*; do
        command -v $arg &> /dev/null || { fail "The command ‘$arg’ is required."; }
    done
}

_listFilterBase() {
    ls -lhHF $2 --color=always --group-directories-first \
                --time-style=long-iso $1 | egrep -v '^total'
}

_onlyHiddenFilter() {
    egrep '.+[[:space:]]([[:cntrl:]]\[([[:digit:]]{2};)*[[:digit:]]{2}m)?\..+'
}

_directoryFilter() { egrep $1 --color=never '^d'; }

ldir() { _listFilterBase $1 | _directoryFilter; }

lldir() { _listFilterBase $1 '-A' | _directoryFilter; }

lhdir() { lldir $1 | _onlyHiddenFilter; }

lf() { _listFilterBase $1 | _directoryFilter '-v'; }

llf() { _listFilterBase $1 '-A' | _directoryFilter '-v'; }

lhf() { llf $1 | _onlyHiddenFilter; }

lh() { _listFilterBase $1 '-A' | _onlyHiddenFilter; }

lz() { du -ahL -d 1 $1 2>/dev/null | sort -h; }

rtmpSniffEnvironment() {
   local setup='setup'
   local teardown='teardown'

   case $1 in
    $setup )
        sudo iptables -t nat -A OUTPUT -p tcp --dport 1935 -j REDIRECT
        rtmpsrv
        ;;
    $teardown )
        sudo iptables -t nat -D OUTPUT -p tcp --dport 1935 -j REDIRECT
        ;;
    *)
        echo "Usage: $0 <$setup|$teardown>"
   esac
}

gitignoreTemplate() {
  if [ $# -gt 0 ]; then
      local baseURL='https://raw.githubusercontent.com/github/gitignore/master/'
      curl -fs ${baseURL}${1}.gitignore >> .gitignore
      if [ $? -ne 0 ]; then
          echo "Language template not found"
      fi
  else
      echo "Usage: $0 <language>"
  fi
}

_setColorscheme() {
    requires xrdb
    echo "URxvt.cursorColor: $1\\n*background: $2\\n*foreground: $3" | xrdb -merge
    killall -s HUP awesome
}

colorscheme() {
   local light='light'
   local dark='dark'
   case $1 in
    $light )
        _setColorscheme "9" "#FFFFFF" "#000000"
        ;;
    $dark )
        _setColorscheme "11" "#000000" "#babdb6"
        ;;
    *)
        echo "Usage: $0 <$light|$dark>"
   esac
}

flac2mp3() {
    requires ffmpeg
    requires parallel

    fileList=()
    local arg
    for arg in $@; do
        if [[ -d "$arg" ]]; then
            local OLDIFS=$IFS
            IFS=$'\n'
            files=( $(find "${arg%/}/" -maxdepth 1 -type f -iname "*.flac") )
            fileList=( ${fileList[@]} ${files[@]} )
            IFS=$OLDIFS
            unset files
        elif [[ -f "$arg"  &&  "${arg##*.}" == "flac" ]]; then
            fileList+=( "$arg" )
        fi
    done
    parallel --no-notice \
        'mp3File={.}.mp3;\
         if [ -f "$mp3File" ]; then echo -e "\e[1;33m[Skipped]\e[0m $mp3File"; fi;\
         ffmpeg -loglevel quiet -nostdin \
                -i {} -f mp3 -vn -ab 320000 "$mp3File";\
         if [ "$?" -eq 0 ]; then echo -e "\e[1;97m[Created]\e[0m $mp3File"; fi;' ::: "${fileList[@]}"
    unset fileList
}

# TODO allow arguments (i.e. -n)
musicRename() {
  requires perl-rename
  perl-rename 'tr/A-Z/a-z/ && s/ /_/g && s/[_-]?[\(\[]?(\d{4}|flac)[\)\]]?//g' $1
}

# osp
create_branch() {
    printf "Insert JIRA password: "
    read -s JIRA_PASSWORD
    printf "\n"
    ruby $AMOS_HOME/common/ci_support/create_branch.rb -j usommerl -p $JIRA_PASSWORD $@
}

birt_server() {
    case $1 in
    "up")
        source $HOME/repos/transtor/config/transtor.amosrc
        source $AMOS_COMMON/smile/set_env.sh
        cd $AMOS_NAT/rails/amos-reports/script/
        jruby server -p 10001 -P /amos-reports
        ;;
    "down")
        pkill -f 'jruby.*amos-reports'
        ;;
    *)
        echo "birt_server [up|down]"
    esac
}

_basename_to_upper() {
  echo "$(basename $1 | tr '[:lower:]' '[:upper:]')"
}

_show_branch() {
  printf "* %-10s: %s\n" "$(_basename_to_upper $1)" "$(git -C $1 rev-parse --abbrev-ref HEAD)"
}

_clean_repo() {
  echo "* Cleaning $(_basename_to_upper $1)"
  git -C $1 clean -f -d
}

_check_branches() {
  for path in "$AMOS_NAT" "${AMOS_NAT}-ng" "$AMOS_COMMON"; do
    [ -e "$path" ] && _show_branch "$path"
  done
}

_clean_repos() {
  for path in "$AMOS_NAT" "${AMOS_NAT}-ng" "$AMOS_COMMON"; do
    [ -e "$path" ] && _clean_repo "$path"
  done
}

_continue_make() {
  read -p 'Continue with project make (y/n) ? ' choice
  case "$choice" in
    y|Y ) echo true;;
    * ) echo false;;
  esac
}

_project_instance() {
  echo $(basename $(dirname "$AMOS_NAT"))
}

_set_dbuser_suffix() {
  local dbuser_suffix="_$(_project_instance)"
  sed -ri "s/(<.*$1>\s+:\s+)([\"\']?)(\w+)([\"\']?)/\1\2\U\3$dbuser_suffix\4/" $AMOS_NAT/config/$2
}

_generate_configs() {
  echo '* Generate configs'
  local vm_properties='env_sample_vm.yml'
  local default_properties='env_default_properties.yml'
  case "$AMOS_PROJ" in
    transtor ) vm_properties='env_vm_properties.yml';;
    russia ) vm_properties='env_amosVirtualBox.yml';;
  esac
  cd $AMOS_NAT/config
  _set_dbuser_suffix 'DBUSER' $vm_properties
  _set_dbuser_suffix 'DBUSER_CM' $default_properties
  ruby generate_configs.rb -p "$default_properties,$vm_properties"
  git checkout $default_properties $vm_properties
  cd $AMOS_NAT
}

_reload_environment() {
  echo '* Reload environment'
  source "${AMOS_NAT}/ci_support/set_env.sh"
}

_make_project() {
  local make_cmd='make install'
  case "$AMOS_PROJ" in
    transtor|russia ) make_cmd='ci_support/ci_make.sh';;
  esac
  cd $AMOS_NAT
  time $make_cmd
}

mmake() {
  if [ -z $AMOS_NAT ]; then
    echo 'Project environment not set'
    return
  fi
  local logfile="$HOME/repos/$(date --iso-8601=seconds)_$(_project_instance)_make.log"
  ( _check_branches
    if [ $(_continue_make) == false ]; then
      rm -f $logfile
      return
    fi
    _clean_repos
    _generate_configs
    _reload_environment
    _make_project ) 2>&1 | tee $logfile
}
}
# vim: set filetype=sh:
